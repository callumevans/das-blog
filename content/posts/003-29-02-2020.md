---
date: "2020-02-29"
title: "Of Microservices and Monoliths"
slug: "posts/of-microservices-and-monoliths/"
description: ""
---
"Microservices vs. Monoliths" has probably been the biggest source of controversy between myself and the substantially less attractive denizens of Manchester that I usually socialise with. Having regularly reflected on and revisited the topic for a few years now, I've found it harder and harder to make sense of the terminology.

We developers have a peculiar obsession with perfectionism: code has to be [as SOLID as possible](../i-probably-dont-understand-solid-principles/); whatever we write should be able to stand-up to business requirements 1/2/3/X years from now; you should be able to swap out your SQL Server database with MongoDB, "just in case". This mentality can lead to some unfortunate software design decisions, where systems are built to stand up to imagined criteria that will _never_ materialise. In many businesses, particularly startups, time is the most valuable resource, and the time it takes to deliver a piece of software could be the metric that deserves the most attention.

Given that line of thinking, there's an argument to be made that blasting out a single, slick and cohesive API and calling it a monolith is faster than dealing with the veritable hellscape of juggling dozens of services, deployments, nodes, clusters and, dare I say, pods. And whilst this _can_ be true, it definitely isn't _always_ true.

I've worked at a couple of companies that have tried to make the transition from a monolithic architecture to microservices. One of them was spurred on by stories from technical powerhouses like Twilio and Uber. The excited, possibly naive, optimism we all regurgitated around the office and pub might be familiar to some. 

>"Twilio have a bunch of microservices. They put them together like lego to create even more functionality, like building blocks. We should do that!"

>"Uber has thousands of microservices. They're very successful. They're very technical. If microservices work for them they should work for us."

And, to be fair, they mostly did work for us.

In this case, our older monolithic architecture was a typically unwieldy ASP Web Forms application that did everything. It worked (and, I hear, still does) very well. There were problems with its maintainability, however. And not necessarily due to bad code. I figure it was mostly considered 'bad' due to the fact it was legacy, which inevitably carries baggage; it was harder for the newer developers to understand, which churn exacerbated over time. There were also things the business wanted to do that made more sense as greenfield projects. Over the course of a few months, a squad structure emerged that promoted self-ownership of most areas of the tech-stack, leaving developers a lot of autonomy with how solutions were implemented. Speed of delivery was the aim of the game, and what we called microservices provided a solution that fit in nicely with how we worked.

That's not to say our approach was without its own problems. We weaved a tangled web of APIs. Services didn't so much talk to each other as they did perform some x-rated parody of a Vulcan mind-meld. A single inbound HTTP request to a public-facing API could easily generate a further two or three internal HTTP requests, and then _they_ risked snowballing into additional requests; any one of links in this chain of requests failing or not returning what it was expected to was a potential point of failure. Scalability was also made more difficult due to this behaviour. If one chatty service was given multiple instances, it would make little to no difference if the various services it talks to weren't also scaled with it.

This unenviable situation is sometimes described as a _distributed monolith_, wherein your architecture features few of the benefits associated with a microservices architecture but has all of the problems. Everything's coupled together, and breaking, scaling or otherwise changing one service affected everything else.

But it did work. And for all our bad decisions and sloppily written services, we were able to develop new services and make ideas a reality quickly, in an increasingly competitive marketplace and deliver some unique, albeit often unpolished, experiences for customers and staff.

Though I don't believe this to be a triumph of a microservices architecture per-se. Rather, it was a testament to the way we worked as a development team. The autonomy of each squad, with their own aims and objectives that in-turn contributed to the business' goals, allowed us to work with the productivity of, arguably, _multiple_ startups. It was only natural that each squad would build their own services, with their own processes and practices, in a way that worked for them.

We likely jumped on some of the definitions too hard. We were eager to "_do microservices_", and we probably weren't content with just having something that worked for us. We had conference calls with other companies. We went to some talks and read some blogs. "_Microservices are agile!_", "_Microservices are scalable_", "_Microservices will make your dick bigger_" and other such delectable buzzword soups are still pretty common.

Suffice it to say, microservices were the in-thing and we definitely wanted to be a part of the hype. We were keen to emulate Uber and Twilio in particular, with their 2000+ microservices. Not realising that they're also global, building atop infrastructure they've spent years developing, and had literally 100x the developers we had. 

Also, it was probably the case that many companies would present talks or publish blog posts detailing their experiences with microservices simply because that was a vogue topic and a shit-hot SEO keyword, which we, perhaps, didn't digest as critically as we should have done.

The notion of _2000+ services_ almost seemed to become the goal in its own right. Our idea of success was measured, in part, by how many services we had.

The microservices bandwagon might not even be a wagon. There is an ongoing curiosity amongst we developers who are trying to get our misshapen heads around some of this fancy vernacular. What is a monolith, and what is a microservice _exactly_? Well, dear reader, I'm sorry to say I can provide no clear answers. Much like every other topic in our esteemed industry, it very much depends on whom you ask.

As far as I can piece together from what people say, what I've read and what I've seen, a _monolith_ can be defined as any vaguely large, singular piece of infrastructure or code. A _microservice_ is, also vaguely, a smaller piece of infrastructure or code that _might_ make up some greater-whole of the system, along with other similarly sized pieces of infrastructure. 

And if you now feel compelled to close this site and never come back after such a characteristically unsatisfying climax, I would absolutely not hold it against you.

There are, of course, more detailed, technical definitions. There are entire books and courses. Reams of documentation to trawl through. You can go to the ends of the earth and back on your journey to understand this new and exciting topic, and make sense of the dilemma that is _to monolith or to microservice?_ And maybe you should. You'll be able to digest and interalise other peoples' real world experiences, problems and solutions and, if nothing else, come away with a broader idea of what's going on with all these definitions.

However, in reading the microservice holy-scriptures of the possibly real, probably evil development deities, you will find some allusion to the idea that microservices are the savior. Successors to the archaic monoliths. That they solve the problems of the past and do away with dated practices. That not adopting microservices will let the competition get a leg-up on you and go to town. To my mind, there is some accidental truth to this, but not much. It is true that it has become easier to leverage the benefits of a microservices-style approach as technologies such as SPAs, cloud infrastructure and continuous integration and deployment processes have come into their own over the years, though that doesn't make it the better design, nor does it necesarrily mitigate many of the bigger downsides.

Another term one might have stumbled across is _service oriented architecture_. This is an old term, by software development standards, and there are a few ways of describing what it means. Google turns up some interesting results, but if you [restrict the search history](https://www.google.co.uk/search?q=service+oriented+architecture&client=safari&hl=en-gb&sxsrf=ALeKk00pHVQNjGqaD9wmJSqgpx0RPwR4uA%3A1587354763797&source=lnt&tbs=cdr%3A1%2Ccd_min%3A%2Ccd_max%3A2003&tbm=) to the early 2000s, we start to get some familiar sounding ideas coming to the forefront. One of the [top results](https://www.service-architecture.com/articles/web-services/service-oriented_architecture_soa_definition.html) (from [service-architecture.com](https://www.service-architecture.com/index.html)), defines SOA thusly: "_A service-oriented architecture is essentially a collection of services. These services communicate with each other._" And that sure as shit sounds a lot like microservices as we know them today.

It's both expected and true to say that terminology evolves over time, and it's completely fair to say that a current interpretation of microservices places them as a subset of a service orientated architecture. However, the ideas aren't new. And you shouldn't feel compelled to jump into them because they're trendy, or because some article has scared you into using them lest your competition outpace you. There's room in this world for both monoliths and microservices; big and small. They've both been around forever, and they can both work.

One observation I occasionally make is that the microservices vs. monolith zeitgeist is prone to going in circles. You start a new job, the legacy system is horrible, and whatever you do next you want to do the opposite. Whatever the infrastructural paradigm is for the legacy system, you probably want to write the next thing to not be it. Lo and behold, the monolith was the problem all along, and microservices were the solution and vice-versa.

These days, it seems more sensible to me to not make decisions to specifically adapt a microservice or monolith approach, but instead to give your attention to how you want to work. Considerations such as how your teams are structured; which group of people will be working on what and how often. What stuff is likely to change at the same time. You'll be thinking about what hosting infrastructure you want to leverage, or what provider to use, and what sort of DevOps culture you want in place to get software onto it. Do you have many products or one, and how tightly integrated are they? What sort of scalability do you need? All of these areas can be discussed without needing to mention the words microservice or monolith.

If you design your architecture to answer these types of questions, and have the confidence to not shoehorn yourself into a paradigm, you might have a better chance of avoiding the pitfalls that a preordained interpretation of microservices or monoliths comes loaded with. Don't feel compelled to squeeze your infrastructure into either definition.

And when you do relax dogma, on one side of that argument or the other, you're more likely to end up with a balanced approach, tailored for your business requirements.

It goes without saying you'll inevitably run into problems, no matter what you do. And I guess that's just software, but at least build it _your_ way.
